//---------------------------------------------------------------------------


#pragma hdrstop

#include "AxisMotion.h"
#include "GlobalFuncs.h"

#pragma package(smart_init)



//---------------------------------------------------------------------------

void TAxisMotion::SetImmediateTarget(double Xt, double Vt, bool IsCircle,int CircularType)
{
IsJ=false;
Ta=0;Ts=0;Td=0;
D1=Xt; V1 = Vt;
D0 = D1; V0 = V1;
a=1; Vm=V1;
this->IsCircle = IsCircle;
this->CircularType = CircularType;
if (IsCircle)
        {
        if (CircularType==CIRCULAR360)
                {
                D0 = _geo_degmod(D0);
                D1 = _geo_degmod(D1);
                }
        else
                {
                D0 = _geo_degmod2(D0);
                D1 = _geo_degmod2(D1);
                }

        }
}

//---------------------------------------------------------------------------

void TAxisMotion::SetTargetSpeed(double Xi, double Vi, double Vt, double Acc, bool IsCircle,int CircularType)
{
IsJ=false;
this->IsCircle = IsCircle;
this->CircularType = CircularType;

if (Equal(Acc,0)) return;
if (Vt<Vi) Acc = -Acc;
a= Acc;
Ta = (Vt - Vi)/a;
Ts = 0;
Td = 0;
D0 = Xi; V0 = Vi;
}

//---------------------------------------------------------------------------

double TAxisMotion::SetTargetDuration (double Xi,double Vi, double Xt, double Vt, double Dur, double Acc, bool IsCircle,int CircularType)
{
this->IsCircle = IsCircle;
this->CircularType = CircularType;

SetTarget(Xi,Vi,Xt,Vt,Acc,1,IsCircle,true);
double AllD = Ta+Ts+Td;
// considering vi = vt = 0

if (IsCircle)
        {
        if (CircularType==CIRCULAR360)
                {
                Xi = _geo_degmod(Xi);
                Xt = _geo_degmod(Xt);
                }
        else
                {
                Xi = _geo_degmod2(Xi);
                Xt = _geo_degmod2(Xt);
                }
         if (Xt>Xi+180) Xi = Xi + 360;
         else if (Xi>Xt+180) Xt = Xt + 360;
        }

if (Xt<Xi) Acc = -Acc;
double Delta = Acc*Acc*Dur*Dur - 4*Acc*(Xt-Xi);
double Vm;
double Ta1,Ta2;
if (Dur<EPSILON) goto Finish;
if (Delta > EPSILON)
        {
        double Ta1 = (Acc*Dur + sqrt(Delta)) / (2*Acc);
        double Ta2 = (Acc*Dur - sqrt(Delta)) / (2*Acc);
        if ((Ta1>EPSILON) && (Ta1<(Dur/2.0))) Ta = Ta1;
                else if ((Ta2>EPSILON) && (Ta2<(Dur/2.0))) Ta = Ta2;
                        else goto NoSolution;

Vm = Ta*fabs(Acc);
SetTarget(Xi,0,Xt,0,fabs(Acc),Vm,IsCircle,false);
goto Finish;
        }
NoSolution:
 {   // Get better acceleration with no speed limit     considering vi=vt=0
     Acc = (Xt-Xi)/(Dur*Dur/4.0);
     SetTarget(Xi,Vi,Xt,Vt,fabs(Acc),1,IsCircle,true);
 }
Finish:
AllD = Ta+Ts+Td;
return fabs(Acc);

//if (AllDuration >= Dur) return AllDuration;    // return the Duration as it can

/*
double Tau = (Dur - AllDuration)/(2.0);
double T = AllDuration / 2.0;

// solve the equation of finding specific duration time
double a = -0.5;
double b = Acc*T+Acc*Tau;
double c = Vi*Tau - 0.5*Acc*T*T;
double Delta = b*b - 4*a*c;
if (Delta <= EPSILON) return AllDuration;
double t1=(-b+sqrt(Delta))/(2*a);
double t2=(-b-sqrt(Delta))/(2*a);
double t;
if (t1>=0) t = t1;
       else if (t2>=0) t = t2;
              else return AllDuration;
double NewVmax = Vi+t*Acc;
SetTarget(Xi,Vi,Xt,Vt,Acc,NewVmax,IsCircle,false);
//return Ta+Ts+Td;

if (Ta+Ts+Td > AllDuration+EPSILON)
        { // Get better acceleration with no speed limit     considering vi=vt=0
        a = Dur / 2.0;
        b = Dur / 2.0;
        c = Xi-Xt;
        Delta = b*b - 4*a*c;
        if (Delta <= EPSILON) return AllDuration;
        double Acc1 = (-b+sqrt(Delta))/(2*a);
        double Acc2 = (-b-sqrt(Delta))/(2*a);
        if (Acc1 > EPSILON) Acc = Acc1;
                else if (Acc2 > EPSILON) Acc = Acc2;
                        else return AllDuration;
SetTarget(Xi,Vi,Xt,Vt,Acc,1,IsCircle,true);
return Ta+Ts+Td;
        }
        */
}


//---------------------------------------------------------------------------

double TAxisMotion::SetTargetPositionSpeedDuration(double Xi,double Vi, double Xt, double Vt, double Duration, double MaxAcc, double Vmax, bool IsCircle, bool InfinitSpeed, int CircularType)
{
this->IsCircle = IsCircle;
this->CircularType = CircularType;

if (IsCircle)
        {
        if (CircularType==CIRCULAR360)
                {
                Xi = _geo_degmod(Xi);
                Xt = _geo_degmod(Xt);
                }
        else
                {
                Xi = _geo_degmod2(Xi);
                Xt = _geo_degmod2(Xt);
                }
         if (Xt>Xi+180) Xi = Xi + 360;
         else if (Xi>Xt+180) Xt = Xt + 360;
        }

double T = Duration;
if (fabs(T)<EPSILON)
        {

        return 0;
        }
 IsJ=true;

 this->J= 12*(Xi-Xt)/(T*T*T) + 6*(Vi+Vt)/(T*T);
 this->a = (Vt-Vi)/(T) - 0.5*J*T;

double Delta1 = a*a - 2*J*(Vi-Vmax);
double Delta2 = a*a - 2*J*(Vi+Vmax);

double T11,T12,T21,T22;
double VInterValue1,VInterValue2;
double T1=-1;
double T2=-1;
if (Delta1>0)
        {
        T11 = (-a+sqrt(Delta1))/(J);
        T12 = (-a-sqrt(Delta1))/(J);
      //  if (T11>0) T1 = T11;
       // if ((T12>0) && (T12<T11)) T1=T12;
        }
if (Delta2>0)
        {
        T21 = (-a+sqrt(Delta2))/(J);
        T22 = (-a-sqrt(Delta2))/(J);
      //  if (T21>0) T2 = T21;
      //  if ((T22>0) && (T22<T21)) T2=T22;
        }



 this->Ta = T; this->Td = 0; this->Ts = 0;
 this->V0 = Vi; this->V1 = Vt; this->Vm = Vmax; this->D0 = Xi ; this->D1 = Xt;

VInterValue1 = GetSpeed((T11+T12)/2.0);
VInterValue2 = GetSpeed((T21+T22)/2.0);

if (VInterValue1>Vmax)
        {
        double Min=T11;
        if (T12<Min) Min=T12;
        T1 = Min;
        if (Min<0) T1=0;
        T=T1;
        SetTarget(Xi,Vi,Xt,Vt,MaxAcc,Vmax,IsCircle,InfinitSpeed,CircularType);
        return -11;
        }
if (VInterValue2<-Vmax)
        {
        double Min=T21;
        if (T22<Min) Min=T22;
        T2 = Min;
        if (Min<0) T2=0;
        T=T2;
        SetTarget(Xi,Vi,Xt,Vt,MaxAcc,Vmax,IsCircle,InfinitSpeed,CircularType);
        return -11;
        }


//else
//        {
//        double Max=T11;
//        if (T12>Max) Max=T12;
//        T1 = Max;
//        if (Max<0) T1=0;
//        }

//else
//        {
//        double Max=T21;
//        if (T22>Max) Max=T22;
//        T2 = Max;
//        if (Max<0) T2=0;
//        }

//VInterValue2 = GetSpeed((T21+T22)/2.0);
 //       {
  //      double Min=T21;
  //      if (T22<Min) Min=T22;
  //      T1 = Min;
  //      if (Min<0) T1=0;
  //      }



//double ResT = T1;
//if (T1>T2) ResT = T2; else ResT=T1;
//if ((ResT>0) && (ResT<T))
//        T=ResT;


this->Ta = T;
double ResV = GetSpeed(Ta);
double ResV2 = GetSpeed(0);

double ResV1 = GetSpeed(T);


if ( ResV< -16)
        {
        int t=1;
        }
if (ResV>16)
        {
        int t=1;
        }

 return J;


        /*
double A,B,B1,B2;
SetTarget(Xi,Vi,Xt,Vt,MaxAcc,Vmax,IsCircle,InfinitSpeed,CircularType);
if (Ta+Ts+Td>=Duration)
        return 0;

int s=0;
if (fabs(Duration<EPSILON))
        {
        A = MaxAcc;
        B = -A;
        }
else
        {
        A=(Xt-Xi-Vi*Duration-(Duration*(Vt-Vi)/4)) / (Duration*Duration/4);
        s=A;
        B1=-A + 2*(Vt-Vi)/Duration;
        if (fabs(A) > MaxAcc)
                {
               if (A>0) A = MaxAcc;
                else A = -MaxAcc;
                }
        B=-A + 2*(Vt-Vi)/Duration;
        B2=8*(Xt-Xi-Vi*Duration-(3*A*Duration*Duration/8.0))/(Duration*Duration);
        B=-B2;
if (fabs(B) > MaxAcc)
        if (B>0) B = MaxAcc;
        else B = -MaxAcc;
        }

 this->Ta = Duration/2; this->Td = Duration/2; this->Ts = 0;
 this->a = A; this->V0 = Vi; this->V1 = Vt; this->Vm = Vmax; this->D0 = Xi ; this->D1 = Xt;
 this->b = B;
 return s;
 if (Ta+Td<0.00001)
        int t=1;
        */


/*
double t1;
if (fabs(Vi-Vt)<EPSILON)
        {  // case equal speed
        double a;
        if (Duration<EPSILON)
                {
                SetTarget(Xi,Vi,Xt,Vt,MaxAcc,Vmax,IsCircle,InfinitSpeed,CircularType);
                return;
                }
        //Duration <> 0
        a = 4*((Xt-Xi-Vi*Duration/2)/(Duration*Duration));
        if (fabs(a)<EPSILON)
                {
                SetTarget(Xi,Vi,Xt,Vt,MaxAcc,Vmax,IsCircle,InfinitSpeed,CircularType);
                return;
                }
        //a <> 0
        double DurUntilVMax;
        if (a>0)  DurUntilVMax =  (Vmax-Vi)/a;
                else
                 DurUntilVMax =  (-Vmax-Vi)/a;
        if (DurUntilVMax > Duration/2.0)
                {
                this->Ta = Duration/2.0; this->Td = Duration/2.0; this->Ts = 0;
                this->a = a; this->V0 = Vi; this->V1 = Vt; this->Vm = Vmax; this->D0 = Xi ; this->D1 = Xt;
                }
        else
                {
                this->Ta = DurUntilVMax; this->Td = DurUntilVMax ; this->Ts = Duration - 2*DurUntilVMax;
                this->a = a; this->V0 = Vi; this->V1 = Vt; this->Vm = Vmax; this->D0 = Xi ; this->D1 = Xt;

                }
        return;
        }
else
        { // case different speeds
        double t1;
        t1 = 2*(Xt-Xi-Vt*Duration)/(Vi-Vt);

if (t1>Duration)
        {
        t1=Duration;
        }
if (t1<=0)
        {
         this->Ta = 0; this->Td = fabs(Vt-V1)/MaxAcc ; this->Ts = 0;
         this->a = MaxAcc; this->V0 = Vi; this->V1 = Vt; this->Vm = Vmax; this->D0 = Xi ; this->D1 = Xt;
         SetTarget(Xi,Vi,Xt,Vt,fabs(a),Vmax,IsCircle,InfinitSpeed,CircularType);
         return;
        }
        a=(Vt-Vi)/t1;
        if (fabs(a)>MaxAcc)
                {
                if (a<0) a = -MaxAcc; else a = MaxAcc;
                t1 = fabs((Vt-Vi)/a);
                }
        this->Ta = 0; this->Td = t1 ; this->Ts = 0;
        this->a = a; this->V0 = Vi; this->V1 = Vt; this->Vm = Vmax; this->D0 = Xi ; this->D1 = Xt;
        SetTarget(Xi,Vi,Xt,Vt,fabs(a),Vmax,IsCircle,InfinitSpeed,CircularType);
        return;
        }
        */
}


//---------------------------------------------------------------------------

void TAxisMotion::SetTarget(double D0,double V0, double D1, double V1, double a, double Vm, bool IsCircle, bool InfinitSpeed,int CircularType)
{
 double Delta;
 double Ta1;
 double Ta2;
 double Td1;
 double Td2;
 double TaMax;
 double D0min;
 this->IsCircle = IsCircle;
 this->CircularType = CircularType;
 IsJ=false;

if (IsCircle)
        {
        if (CircularType==CIRCULAR360)
                {
                D0 = _geo_degmod(D0);
                D1 = _geo_degmod(D1);
                }
        else
                {
                D0 = _geo_degmod2(D0);
                D1 = _geo_degmod2(D1);
                }
         if (D1>D0+180) D0 = D0 + 360;
         else if (D0>D1+180) D1 = D1 + 360;
        }

 if (fabs(a)<EPSILON) return;
 if (fabs(V1)>=fabs(Vm))
        {
        //V1 = sign(V1) * fabs(Vm);
        Ta= fabs(((sign(V1)*Vm)-V0)/a);
        if (V1<V0) {a=-a; Vm=-Vm;}
        Td=0;
        Ts=0;
        }
 else
 {
 double Tamin = fabs((V1-V0)/a);
 double D1min = D1 + Tamin*V1;
 D1min = D1+Tamin*V1;

 if (V0<=V1)
       D0min = D0 + V0*Tamin + 0.5*a*Tamin*Tamin;
 else  D0min = D0 + V0*Tamin - 0.5*a*Tamin*Tamin;
 if ((V0<=V1) && (D1min<=D0min)) {a=-a; Vm=-Vm;}
 else if ((V0>=V1) && (D1min<=D0min)) {a=-a; Vm=-Vm;}
 Delta = pow((2*V0-2*V1),2) - 4*a*((pow((V0-V1),2)/(2*a)) + D0 - D1);
 //Delta = 0;
 if ((Delta <0) && (Delta>-EPSILON)) Delta = 0;
 if (Delta < 0)
        {
        Ta = -1; Ts = -1; Td = -1;
        }
 else
        {
 Ta1 = (-2*V0+2*V1+sqrt(Delta))/(2*a);
 Ta2 = (-2*V0+2*V1-sqrt(Delta))/(2*a);
 if (fabs(Ta1)<EPSILON) Ta1 = 0;
 if (fabs(Ta2)<EPSILON) Ta2 = 0;
 Td1 = (V0+a*Ta1-V1)/a;
 Td2 = (V0+a*Ta2-V1)/a;
 if (fabs(Td1)<EPSILON) Td1 = 0;
 if (fabs(Td2)<EPSILON) Ta2 = 0;
 TaMax =  (Vm-V0)/a;
 if (TaMax<0)
        TaMax = 0;

if (InfinitSpeed == true)
        {
        if ((Ta1>=0) && (Td1>=0)) {Ta=Ta1;Ts=0;Td=Td1;}
         else  if ((Ta2>=0) && (Td2>=0)) {Ta=Ta2;Ts=0;Td=Td2;}
         else
                {
                LogFile.PutLog(LOG_ERROR,"Path calculation with infinite speed could not be calculated");
                }
        }
else
{
 if ((Ta1>=0) && (Td1>=0) && (Ta1<=TaMax)) {Ta=Ta1;Ts=0;Td=Td1;}
 else  if ((Ta2>=0) && (Td2>=0) && (Ta2<=TaMax)) {Ta=Ta2;Ts=0;Td=Td2;}
 else if ((Ta1>TaMax) || (Ta2>TaMax))
        {
        Ta = TaMax;
        Td = (V0+a*Ta-V1)/a;
        if (fabs(V1-Vm) < EPSILON)
                {
                Td = 0;
                Ts = 0;
                }
        else
        Ts = (D0-D1-V1*Ta - V1*Td + V0*Ta + 0.5*a*Ta*Ta + Vm*Td - 0.5*a*Td*Td )/(V1-Vm);
        }
 else {
        LogFile.PutLog(LOG_ERROR,"Path calculation could not be calculated");
       }
       }
}
if ((Ta<-EPSILON) || (Td<-EPSILON) || (Ts<-EPSILON))
        {
        static int i=0;
        i++;
        LogFile.PutLog(LOG_ERROR,"Wrong path calculation results") ;
        }

     double D = D0 + 0.5*a*Ta*Ta + V0*Ta + (V0+a*Ta)*Ts + (V0+a*Ta)*Td - 0.5*a*Td*Td;
     double D3 = D1 + V1*(Ta+Ts+Td);
 if (fabs(D-D3) > EPSILON)
        {
        //int o=0;
        //LogFile.PutLog(LOG_WARNING,"Path calculation with considerable errors");
        }
}
 this->Ta = Ta; this->Td = Td; this->Ts = Ts;
 this->a = a; this->V0 = V0; this->V1 = V1; this->Vm = Vm; this->D0 = D0 ; this->D1 = D1;
 this->b = a;
}


//------------------------CalculateSpeed--------------------------------------------------
double TAxisMotion::GetSpeed(double T)
{
if (IsJ==true)
        {
        double V;
        if (T<0) return 0;
        if (T<Ta) V = V0 + a*T + 0.5*J*T*T;
        else V = V0 + a*Ta + 0.5*J*Ta*Ta;
    //    if (V>Vm)
    //            V = Vm;
    //    if (V<-16)
    //            V = -Vm;
        return V;
        }
if (T<0) return 0;
if (T<Ta) return V0 + a*T;
if (T<Ta + Ts) return V0+ a*Ta; // same as Vm
if (T<Ta+Ts+Td) return (V0+ a*Ta) - b*(T-Ta-Ts);
if (T>=Ta+Ts+Td) return (V0+ a*Ta) - b*(Td);
return V1;       // must be epsilon and move toward 0
}

//------------------------CalculateSpeed--------------------------------------------------
double TAxisMotion::GetPosition(double T)
{
double Res=0;
if (IsJ==true)
        {
        if (T<0) Res = 0;
        else if (T<Ta) Res = D0 + V0*T + 0.5*a*T*T + (1.0/6.0)*J*T*T*T;
        else Res =        D0 + V0*Ta + 0.5*a*Ta*Ta + (1.0/6.0)*J*Ta*Ta*Ta + (V0 + a*Ta + 0.5*J*Ta*Ta)*(T-Ta);

        }
else
        {
if (T<0) Res = 0;
        else if (T<Ta) Res = D0 + V0*T + 0.5*a*T*T;
        else if (T<Ta + Ts) Res =  D0 + V0*Ta + 0.5*a*Ta*Ta +(T-Ta)*(V0+ a*Ta); // same as Vm
        else if (T<Ta+Ts+Td) Res = D0 + V0*Ta + 0.5*a*Ta*Ta +(Ts)*(V0+ a*Ta) + (V0+ a*Ta)*(T-Ta-Ts) - 0.5*b*(T-Ta-Ts)*(T-Ta-Ts);
        else if (T>=Ta+Ts+Td) Res = D0 + V0*Ta + 0.5*a*Ta*Ta +(Ts)*(V0+ a*Ta) + (V0+ a*Ta)*(Td) - 0.5*b*(Td)*(Td) + (V0+ a*Ta - b*Td)*(T-Ta-Ts-Td);
        }

if (IsCircle == false)
        return Res;
else
        if (CircularType==CIRCULAR360)
                return _geo_degmod(Res);
        else
                return _geo_degmod2(Res);
}

